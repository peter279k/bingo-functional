[{"url":"\/changes.html","title":"bingo-functional change log","content":"bingo-functional change log\n\nv1.0.0\n\nHelpers\n\n- compose()\n- constantFunction()\n- curry()\n- curryN()\n- extend()\n- identity()\n- memoize()\n- partial()\n- pick()\n- pluck()\n- zip()\n- unzip()\n\nFunctors\n\n- Either Left\/Right\n- Maybe Just\/Nothing\n- Applicatives Applicative\/CollectionApplicative\n- Monad Monad\n\nv1.1.0\n\nNew Helper functions\n\n- head()\n- tail()\n- partition()\n\nv1.2.0\n\nNew Helper functions\n\n- isArrayOf()\n- partialRight()\n- partialLeft() as a replacement for partial()\n\nNew Functor features\n\n- TransientMutatorTrait TransientMutatorTrait\n\nv1.2.1\n\nFixed the following problem(s)\n\n-\n\nthe error message shown when a mixed array (array containing more than one type) is supplied to the isArray() function.\n\n-\n\nthe partialRight() behavior of partialLeft()\n\nv1.3.0\n\nAdded the following functions to the Monad functor\n\n- filter()\n- flatMap()\n\nv1.4.0\n\nMade the following change(s)\n\n-\n\nthe pluck(), pick(), isArrayOf(), and memoize() functions have been given callback signatures.\n\n-\n\nthe extractErrorMessage() function and all other related callback functions have been replaced.\n\n-\n\nthe Monad class has been replaced with new Monads: IO, Reader, Writer, and State.\n\nNew helper functions\n\n- concat()\n- throttle()\n\nNew callback functions\n\n- invalidArrayKey()\n- invalidArrayValue()\n- emptyArray()\n- memoizationError()\n\nNew monads\n\n- State monad\n- IO monad\n- Reader monad\n- Writer monad\n\nv1.5.0\n\nNew Helper functions\n\n- map()\n- filter()\n- fold()\n- reduce()\n\nv1.6.0\n\nMade the following change(s)\n\n-\n\nModified the filter() function to accurately filter values whenever a boolean predicate is defined.\n\n-\n\nChanged parameter order of the return value for the reduce() function.\n\nNew Helper Functions\n\n- arrayKeysExist()\n- dropLeft()\n- dropRight()\n- unique()\n- flatten()\n- compact()\n\nv1.7.0\n\nNew monad\n\n- ListMonad\n\nv1.7.1\n\nMade the following change(s)\n\n-\n\nModified the throttle() function to accept multiple arguments\n\n-\n\nAdded type signatures and doc blocks for functions without any\n\n-\n\nAdded immutable const definition for concat() function\n\nv1.7.2\n\nMade the following change(s)\n\n-\n\nModified the orElse() methods of the Left, Right, Nothing, and Just functors\n\n-\n\nAdded the flatMap() method to the State and List monads\n\nv1.8.0\n\n- Added pattern matching to library\n\nRemoved the following callback function(s)\n\n- invalidArrayKey()\n- invalidArrayValue()\n- emptyArray()\n- memoizationError()\n\nModified the following function(s)\n\n- map()\n- pick()\n- fold()\n- pluck()\n- reduce()\n- filter()\n- memoize()\n- isArrayOf()\n\nNew Helper functions\n\n- fill()\n- partial()\n- indexOf()\n- reverse()\n- toPairs()\n- fromPairs()\n- match()\n\nv1.9.0\n\n- Added more robust pattern matching to library\n\nModified the following functions\n\n- dropLeft()\n- dropRight()\n- map()\n- filter()\n\nNew Helper functions\n\n- every()\n- any()\n- where()\n- reduceRight()\n- foldRight()\n- min()\n- max()\n- groupBy()\n- patternMatch()","description":"Change log for the project"},{"url":"\/collection.html","title":"\/collection.html","content":"Picking\n\npick(array $collection, mixed $value)\n\nSince: v1.0.0\n\nArguments:\n\n- collection (array) - The array from which a value is to be picked\n- value (mixed) - The value to pick\n\nPicking is a means of selecting an item from a list. This list, is, usually an array.\n\n$list = ['Spurs', 'Rockets', 'Heat', 'Pelicans'];\n\n$picked = A\\pick($list, 'Heat'); \/\/returns 'Heat'\n\nPlucking\n\npluck(array $collection, mixed $key)\n\nSince: v1.0.0\n\nArguments:\n\n- collection (array) - The array from which a value is to be picked\n- key (mixed) - The key the corresponding value to which is returned\n\nLike picking, plucking is a means of selecting an item from a list. The difference is in the means of selection. Plucking selects an item by index.\n\n$list = ['PG' => 'Dragic', 'SG' => 'Reddick', 'SF' => 'Durant'];\n\n$plucked = A\\pluck($list, 'SF'); \/\/returns 'Durant'\n\nZipping\n\nzip(callable $function = null, array ...$arrays)\n\nSince: v1.0.0\n\nArguments:\n\n- function (callable) - The zip function\n- arrays (array) - The arrays to zip\n\nAlso used to manipulate lists is zipping. A zipped array is a multidimensional array of grouped arrays. It can be created either via function binding or array key combination.\n\n$pos = ['PG', 'SG', 'SF'];\n$players = ['Dragic', 'Reddick', 'Durant'];\n\n$zippedKeys = A\\zip(null, $pos, $players); \/\/key combination\n\/\/should return [['PG', 'Dragic'], ['SG', 'Reddick'], ['SF', 'Durant']]\n\n$zippedFn = A\\zip(\n    function (string $player, string $pos) : string {\n        return $player . ' is a ' . $pos;\n    },\n    $players,\n    $pos\n);\n\/\/should return ['Dragic is a PG', 'Reddick is a SG', 'Durant is a SF']\n\nUnzipping\n\nunzip(array $zipped)\n\nSince: v1.0.0\n\nArguments:\n\n- zipped (array) - The zipped array\n\nThe antithesis of zipping, unzipping involves transforming a zipped array into a multidimensional array of non-grouped arrays.\n\n\/\/borrowing from the previous snippet\n\n$unzipped = A\\unzip($zippedKeys);\n\/\/should return [['PG', 'SG', 'SF'], ['Dragic', 'Reddick', 'Durant']]\n\nExtend\n\nextend(array ...arrays)\n\nSince: v1.0.0\n\nArguments:\n\n- arrays (array) - The arrays to combine\n\nThe extend function is inspired by a similar bilby.js functional library. This helper is, in essence, used on arrays and allows one to append elements to them.\n\n$players = ['PG' => 'Dragic', 'SG' => 'Winslow'];\n\n$extended = A\\extend($players, ['SF' => 'Durant', 'PG' => 'Curry']);\n\/\/should return ['PG' => 'Curry', 'SG' => 'Winslow', 'SF' => 'Durant']\n\nHead function\n\nhead(array $array)\n\nSince: v1.1.0\n\nArguments:\n\n- array (array) - The array whose first element is to be computed\n\nThe output of the head function is the first value of an array.\n\n$head = A\\head([1, 2, 3, 4]);\n\/\/returns 1\n\nTail function\n\ntail(array $array)\n\nSince: v1.1.0\n\nArguments:\n\n- array (array) - The array whose elements other than the first are to be returned\n\nContrary to the head function, the tail function returns the second to last values in an array.\n\n$tail = A\\tail([1, 2, 3, 4]);\n\/\/returns [2, 3, 4]\n\nindexOf function\n\nindexOf(array $array, mixed $value)\n\nSince: v1.8.0\n\nArguments:\n\n- array (array) - The array from which an index of a list item is to be computed\n- value (mixed) - The array item whose index is to be computed\n\nThe indexOf function computes the list index of a given list item.\n\n$index = A\\indexOf([1, 2, 3, 4], 2);\n\necho $index; \/\/outputs 1\n\nFill function\n\nfill(array $array, mixed $value, int $startIndex, int $endIndex)\n\nSince: v1.8.0\n\nArguments:\n\n- array (array) - The array to fill with a value\n- value (mixed) - The fill value\n- startIndex (int) - The first index whose corresponding value is to be replaced with fill value\n- endIndex (int) - The last index whose corresponding value is to be replaced with fill value\n\nThe fill function replaces the values of specified list indexes with an arbitrary value.\n\n$filled = A\\fill([2, 4, 6, 7], 3, 1, 2);\n\nvar_dump($filled); \/\/outputs [2, 3, 3, 7]\n\nPartitioning\n\npartition(int $size, array $array)\n\nSince: v1.1.0\n\nArguments:\n\n- size (int) - The size of the partitions\n- array (array) - The array to partition\n\nThe partition function one which can be used to create a multidimensional array expressed as a collection of smaller arrays of a defined size.\n\n$partitioned = A\\partition(2, [1, 2, 3, 4]);\n\/\/returns [[1, 2], [3, 4]]\n\nisArrayOf function\n\nisArrayOf(array $array)\n\nSince: v1.2.0\n\nArguments:\n\n- array (array) - The array whose predominant type is to be ascertained\n\nReturns a string identifying the predominant type of the array. Arrays with more than one type are considered mixed.\n\n$integers = [1, 2, 3, 4];\n\necho A\\isArrayOf($integers);\n\/\/prints 'integer'\n\nconcat function\n\nconcat(string $wildcard, string ...strings)\n\nSince: v1.4.0\n\nArguments:\n\n- wildcard (string) - The wildcard to be used\n- strings (string) - The strings to concatenate\n\nThe concat() function concatenates strings. It appends strings onto each other sequentially. It requires a wildcard separator though.\n\n$wildcard = ' ';\n\necho A\\concat($wildcard, 'Kampala', 'is', 'hot');\n\/\/should print 'Kampala is hot'\n\nMap function\n\nmap(callable $function, array $collection)\n\nSince: v1.5.0\n\nArguments:\n\n- function (callable) - The function to map onto array values\n- collection (array) - The array whose values are transformed\n\nThe map function transforms each entry in a collection. The requirements for this are a function whose return value dictates the transformation and an array of values.\n\n$collection = [2, 4, 6, 8];\n\n$squareOf = A\\map(\n    function (int $val) : int {\n        return pow($val, 2);\n    },\n    $collection\n); \/\/should evaluate to [4, 16, 36, 64]\n\nFilter function\n\nfilter(callable $function, array $collection)\n\nSince: v1.5.0\n\nArguments:\n\n- function (callable) - The filter function\n- collection (array) - The array whose values are evaluated\n\nTo filter is to make a selection based on a boolean predicate - the filter function, therefore, makes it possible to select array values based on a filter function's boolean return value.\n\n$collection = [1, 2, 3, 4, 5, 6];\n\n$even = A\\filter(\n    function (int $val) : bool {\n        return $val % 2 === 0;\n    },\n    $collection\n);\n\/\/should return [2, 4, 6]\n\nFold\/Reduce function\n\nfold\/reduce(callable $function, array $collection, mixed $acc)\n\nSince: v1.5.0\n\nArguments:\n\n- function (callable) - The filter function\n- collection (array) - The array whose values are evaluated\n- acc (mixed) - The accumulator value\n\nThe reduce function otherwise known as the fold function is one used purposely to transform a collection into a single value.\n\n$collection = [1, 2, 3, 4, 5, 6];\n\n$sumOfEven = A\\fold(\n    function (int $acc, int $val) : int {\n        return $val % 2 === 0 ? $acc + $val : $acc;\n    },\n    $collection,\n    0\n);\n\/\/should evaluate to 12\n\nReduceRight function\n\nSince: v1.8.1\n\nArguments:\n\n- function (callable) - The filter function\n- collection (array) - The array whose values are evaluated\n- acc (mixed) - The accumulator value\n\nFolds an array but does so from right to left.\n\n$collection = [\"foo\", \"bar\", \"baz\"];\n\n$sumOfEven = A\\fold(\n    function (string $separator, string $val) : string {\n        return rtrim($val . $separator, $separator);\n    },\n    $collection,\n    '_'\n);\n\/\/evaluates to \"baz_bar_foo\"\n\nUnique function\n\nunique(array $array)\n\nSince: v1.6.0\n\nArguments:\n\n- array (array) - The array from which duplicates are purged\n\nThe unique function removes duplicates from an array.\n\n$numbers = [1, 2, 3, 4, 1];\n\n$unique = A\\unique($numbers); \/\/should return [1, 2, 3, 4]\n\nCompact function\n\ncompact(array $array)\n\nSince: v1.6.0\n\nArguments:\n\n- array (array) - The array from which falsey values are purged\n\nThe compact function purges an array of falsey values (null, false).\n\n$collection = [1, 2, 3, false, null];\n\n$numbers = A\\compact($collection); \/\/evaluates to [1, 2, 3]\n\nDrop function\n\ndropLeft\/dropRight(array $array, int $count)\n\nSince: v1.6.0\n\nArguments:\n\n- array (array) - The array from which values are to be dropped\n- count (int) - The number of items to drop\n\nThe drop functions remove items from a list. The dropLeft() function removes elements from the front of a collection. The dropRight() function, on the other hand, removes elements from the back of a list.\n\n$even = [2, 4, 6, 8, 10, 12];\n\n\/\/dropLeft\n$leftDrop = A\\dropLeft($even, 3); \/\/evaluates to [8, 10, 12]\n\n\/\/dropRight\n$rightDrop = A\\dropRight($even, 3); \/\/evaluates to [2, 4, 6]\n\nFlatten function\n\nflatten(array $array)\n\nSince: v1.6.0\n\nArguments:\n\n- array (array) - The array to flatten\n\nThe flatten function reduces an array level count by one.\n\n$collection = [[1, 2], 'foo', 'bar'];\n\n$flattened = A\\flatten($collection); \/\/evaluates to [1, 2, 'foo', 'bar']\n\nArrayKeysExist function\n\narrayKeysExist(array $array, mixed ...$keys)\n\nSince: v1.6.0\n\nArguments:\n\n- array (array) - The array whose keys are to be assessed\n- keys (mixed) - The keys whose existence is to be ascertained\n\nThe arrayKeysExist function determines whether specified keys match the indexes of the values in an array and therefore exist in a collection.\n\n$attributes = ['username' => 'foo', 'password' => 'bar'];\n\n$keysExist = A\\arrayKeysExist($attributes, 'username', 'password'); \/\/should evaluate to true\n\nReverse function\n\nreverse(array $array)\n\nSince: v1.8.0\n\nArguments:\n\n- array (array) - The array whose order is to be reversed\n\nThe reverse function computes the reverse of an array.\n\n$reverse = A\\reverse(['foo', 'bar', 'baz']);\n\nvar_dump($reverse); \/\/outputs ['baz', 'bar', 'foo']\n\nToPairs function\n\ntoPairs(array $array)\n\nSince: v1.6.0\n\nArguments:\n\n- array (array) - The array from which pairs are to be formed\n\nThe toPairs function combines key-value pairs into discrete array pairs.\n\n$toPairs = A\\toPairs(['foo' => 'baz', 'bar' => 'baz', 'boo' => 1]);\n\nvar_dump($toPairs); \/\/prints [['foo', 'baz'], ['bar', 'baz'], ['boo', 1]]\n\nFromPairs function\n\nfromPairs(array $array)\n\nSince: v1.8.0\n\nArguments:\n\n- array (array) - A key-value collection\n\nThe fromPairs function forms key-value pairs from discrete array pairs - it is the opposite of the toPairs function.\n\n$fromPairs = A\\fromPairs([['foo', 'baz'], ['bar', 'baz'], ['boo', 1]]);\n\nvar_dump($fromPairs); \/\/outputs ['foo' => 'baz', 'bar' => 'baz', 'boo' => 1]\n\nEvery function\n\nevery(array $array, callable $function)\n\nSince: v1.8.1\n\nArguments\n\n- array (array) - The key-value collection\n- function (callable) - The function whose boolean assertion is used\n\nThe every function checks if a boolean assertion in a function holds for every value in a list.\n\n$result = A\\every(\n    [1, 2, 3, 4],\n    function ($val) : bool {\n        return is_int($val);\n    }\n);\n\necho $result; \/\/outputs true\n\nAny function\n\nany(array $array, callable $function)\n\nSince: v1.8.1\n\nArguments\n\n- array (array) - The key-value collection\n- function (callable) - The function whose boolean assertion is used\n\nThe any function, unlike its relative, the every function, checks if a single value in a list conforms to the boolean predicate in a function signature.\n\n$result = A\\any(\n    [false, true, 1, 2, 3],\n    function ($val) : bool {\n        return is_bool($val);\n    }\n);\n\necho $result; \/\/outputs true\n\nGroupBy function\n\ngroupBy(array $array, mixed $key)\n\nSince: v1.8.1\n\nArguments\n\n- array (array) - The array to sort\n- key (mixed) - The key to use for the grouping\n\nThe groupBy function is one that sorts a multi-dimensional array by a defined key.\n\n$group = A\\groupBy(\n    [\n        ['pos' => 'pg', 'name' => 'dragic'],\n        ['pos' => 'sg', 'name' => 'jordan'],\n        ['pos' => 'sg', 'name' => 'wade']\n    ],\n    'pos'\n);\n\nvar_dump($group);\n\/\/outputs ['pg' => [['pos' => 'pg', 'name' => 'dragic']], 'sg' => [['pos' => 'sg', 'name' => 'jordan'], ['pos' => 'sg', 'name' => 'wade']]]\n\nWhere function\n\nwhere(array $list, array $search)\n\nSince: v1.8.1\n\nArguments\n\n- list (array) - The array to search\n- search (array) - The list fragment that is the basis for the search\n\nThe where function searches a multi-dimensional array using a fragment of a sub-array defined in said multi-dimensional array.\n\n$result = A\\where(\n    [\n        ['pos' => 'pg', 'name' => 'dragic'],\n        ['pos' => 'sg', 'name' => 'wade']\n    ],\n    ['name' => 'dragic']\n);\n\nvar_dump($result);\n\/\/outputs [['pos' => 'pg', 'name' => 'dragic']]\n\nMin function\n\nmin(array $array)\n\nSince: v1.8.1\n\nArguments\n\n- array (array) - The list whose lowest value is to be computed\n\nFinds the lowest value in an array.\n\n$min = A\\min([22, 19, 12, 98]);\n\necho $min; \/\/outputs 12\n\nMax function\n\nmax(array $array)\n\nSince: v1.8.1\n\nArguments\n\n- array (array) - The list whose largest value is to be computed\n\nFinds the largest value in an array.\n\n$max = A\\max([22, 19, 98, 12]);\n\necho $max; \/\/outputs 98","description":"Documentation for helper functions used on collections"},{"url":"\/functions.html","title":"\/functions.html","content":"Composing functions\n\ncompose(callable ...$functions)\n\nThe ability to combine functions is a concept borrowed from mathematics. Simply put, composition is applying a function to the output of another function thereby transforming it. A function f and another function g can be 'composed' to create a function f o g.\n\nSince: v1.0.0\n\nArguments:\n\n- functions (callable) - The functions to chain\n\nuse Chemem\\Bingo\\Functional\\Algorithms as A;\n\n$composed = A\\compose(\n    function (int $a) : int {\n        return $a + 10;\n    },\n    function (int $a) : int {\n        return $a * 10;\n    }\n); \/\/could be any callable value(s)\n\n$output = array_map($composed, [1, 2, 3]);\n\/\/should return [110, 120, 130]\n\nPartial application\n\npartial(callable $function, mixed ...$args)(mixed ...$args)\n\nIf the intention is to supply parameters to a function incrementally, partial application is a possible solution. At the core of partial application is binding arguments to a function.\n\nSince: 1.0.0, excluded from versions 1.2.0 to 1.7.2\n\nArguments:\n\n- function (callable) - The function to which arguments are partially applied\n- args (mixed) - The arguments to bind to the function\n\n$partial = A\\partial(\n    function (int $a, int $b) : int {\n        return $a + $b;\n    },\n    1\n); \/\/bind the argument 1 to the function\n\n$partial(2); \/\/bind 2 to the function; should return 3\n\nPartial-Left\n\npartialLeft(callable $function, mixed ...$args)(mixed ...$args)\n\nSince: v1.2.0\n\nArguments:\n\n- function (callable) - The function to which arguments are partially applied\n- args (mixed) - The arguments to bind to the function\n\nWorks just like the partial function. Arguments are, with the partialLeft function, incrementally supplied from left to right.\n\n$partialLeft = A\\partialLeft(\n    function (int $a, int $b) : int {\n        return $a - $b;\n    },\n    12\n);\n\n$partialLeft(9); \/\/should output 3\n\nPartial-Right\n\npartialRight(callable $function, mixed ...$args)(mixed ...$args)\n\nSince: v1.2.0\n\nArguments:\n\n- function (callable) - The function to which arguments are partially applied\n- args (mixed) - The arguments to bind to the function\n\nThis is the antipode of the partialLeft function. The argument order is right to left.\n\n$partialRight = A\\partialRight(\n    function (int $a, int $b) : int {\n        return $a - $b;\n    },\n    9\n);\n\n$partialRight(12); \/\/outputs 3\n\nCurrying\n\ncurry(callable $function)\n\nSince: v1.0.0\n\nArguments:\n\n- function (callable) - The function to curry\n\nRelated to partial application is currying which is premised on splitting a higher-order function into smaller functions each taking a single argument. The idea of binding arguments to a function incrementally features strongly here as well.\n\n$curryied = A\\curry(\n    function (int $a, int $b) : int {\n        return $a * $b;\n    }\n);\n\n$curryied(4)(5); \/\/should return 20\n\ncurryRight\n\ncurryRight(callable $function)\n\nSince: v1.8.1\n\nArguments:\n\n- function (callable) - The function to curry\n\nCurry a function from right to left.\n\n$curryiedRight = A\\curryRight(\n    function (int $a, int $b) {\n        return $a \/ $b;\n    }\n);\n\n$curryiedRight(4)(8); \/\/outputs 2\n\nCurryN\n\ncurryN(int $paramCount, callable $function)\n\nSince: v1.0.0\n\nArguments:\n\n- paramCount (int) - The number of parameters to curry\n- function (callable) - The function to curry\n\nThe curryN function allows for specifying the number of parameters to curry. This can be used for functions with default\/optional parameters.\n\n$curryied = A\\curryN(\n    2,\n    function (int $a, int $b, int $c = null) : int {\n        return $a + $b + $c;\n    }\n);\n\n$curryied(2)(3); \/\/should return 5\n\ncurryRightN\n\ncurryRightN(int $paramCount, callable $function)\n\nSince: v1.8.1\n\nArguments:\n\n- paramCount (int) - The number of parameters to curry\n- function (callable) - The function to curry\n\nSimilar to the curryN function but best suited for currying from right to left.\n\n$curryied = A\\curryRightN(\n    2,\n    function (int $a = 1, int $b, int $c) : int {\n        return $a + $b + $c;\n    }\n);\n\n$curryied(2)(3); \/\/evaluates to 6\n\nIdentity\n\nidentity(mixed $value)\n\nSince: v1.0.0\n\nArguments:\n\n- value (mixed) - An arbitrary value\n\nCentral to the identity law of functors is the identity function. This function is pretty straightforward; it returns the value it receives with no transformations whatsoever.\n\n$id = A\\identity('foo');\n\/\/should return foo\n\nConstant function\n\nconstantFunction(mixed $value)\n\nSince: v1.0.0\n\nArguments:\n\n- value (mixed) - An arbitrary value\n\nThe constant function is one that always returns the first argument it receives.\n\n$const = A\\constantFunction(1);\n$const(); \/\/should return 1\n\nThrottle function\n\nthrottle(callable $function, int $time)(mixed ...$args)\n\nSince: v1.4.0\n\nArguments:\n\n- function (callable) - The function to throttle\n- time (int) - The throttle time\n- args (mixed) - The function arguments\n\nThe throttle function is used to defer function processing.\n\n$addTwelve = function (int $val) : int {\n    return $val + 12;\n};\n\n$throttle = A\\throttle($addTwelve, 10);\n\necho $throttle(0);\n\/\/prints the digit 12 after 10 seconds\n\nNote: The throttle function as of v1.7.1 supports functions with multiple arguments.\n\nMemoize function\n\nmemoize(callable $function)\n\nSince: v1.0.0\n\nArguments:\n\n- function (callable) - The function to memoize\n\nSometimes, a computation might be expensive. Memoization ensures that the output of a computed result is cached and conveyed.\n\n$factorial = A\\memoize(\n    function (int $num) use (&$factorial) {\n        return $num < 2 ? 1 : $factorial($num - 1) * $num;\n    }\n);\n\n$factorial(130); \/\/outputs float(6.4668554892205E+219)\n\nCallback signatures\n\nNote: Callbacks will not be usable beyond bingo-functional v1.7.2. Check out the [changelog](https:\/\/ace411.github.io\/bingo-functional\/changes).\n\nThese are essential for proper functioning of the the following helper functions: pluck(), pick(), memoize(), as well as isArrayOf(). The following callback signatures correspond to the functions listed:\n\n-\n\ninvalidArrayKey :: key -> errMsg\n\n-\n\ninvalidArrayValue :: key -> errMsg\n\n-\n\nmemoizationError :: Callable fn -> errMsg\n\n-\n\nemptyArray :: Nothing -> errMsg\n\nNote: You can write your own callbacks provided they adhere to the signatures listed above.","description":"Documentation for helper functions used on functions"},{"url":"\/functors.html","title":"\/functors.html","content":"A functor is an entity derived from Category Mathematics. Functors allow one to map functions to one or more values defined in their context. Functors are, therefore, the data structures that form the basis for Monads, Applicatives, Just\/Nothing types, and Left\/Right types.\n\nApplicatives\n\nAn applicative is a functor which conforms to certain laws - interchange, map, identity, and homomorphism. The most pervasive element of applicatives is the ability to apply a function to the values in their context.\n\nFunctions, arrays, objects, and primitives can be encapsulated in Applicatives.\n\nuse Chemem\\Bingo\\Functional\\Functors\\{CollectionApplicative, Applicative};\n\n$num = Applicative::pure(10); \/\/should return an integer, 10 encapsulated in an Applicative object\n\n$addTen = Applicative::pure(\n    function (int $a) : int {\n        return $a + 10;\n    }\n); \/\/should return a Closure object encapsulated in an Applicative object\n\nCollectionApplicatives\n\nApplicatives and CollectionApplicatives are not entirely dissimilar. The latter functors are indeed applicatives but more amenable to the creation of [ziplists](http:\/\/hackage.haskell.org\/package\/base-4.10.0.0\/docs\/Control-Applicative.html#v:ZipList), which are, fundamentally, traversable data structures.\n\n$zipList = CollectionApplicative::pure([\n    $addTen,\n    function (int $a) : int {\n        return $a * 10;\n    }\n])\n->apply(\n    CollectionApplicative::pure([1, 2, 3])\n)\n->getValues();\n\/\/should return [11, 12, 13, 10, 20, 30]\n\nUsing the apply method\n\nThe apply method is simply a means of binding an argument to a function defined in the context of an Applicative. It is especially convenient for state transformations within a functor environment.\n\n$addTen->apply($num)\n    ->getValue(); \/\/should return 20\n\nMonad\n\nThe monad implementation in this library is a simple one. Considering the existence of a complete genealogy of monads, the monad class in this library is a microcosm of the feature. Monads allow us to manipulate values within their context like Applicatives but return monads of the same type when functions are bound to them.\n\nuse Chemem\\Bingo\\Functional\\Functors\\Monad;\n\n$val = Monad::return(10)\n    ->bind(\n        function (int $val) : int {\n            return $val + 10;\n        }\n    ); \/\/returns the value 10 encapsulated in a Monad object\n\nMonads map functions onto values stored inside their contexts whereas Applicatives bind values to the functions stored inside theirs.\n\nNote: As of version 1.4.0, the Monad class will not be available. Refer to the [change log](https:\/\/github.com\/ace411\/bingo-functional\/blob\/master\/docs\/changes.html) for more details.\n\nThe IO Monad\n\nThe IO monad is one built purposely for handling impure operations. Impure operations are those that break referential transparency and immutability. Database interactions, web service interaction, as well as external file reads are impediments to referential transparency.\n\nuse Chemem\\Bingo\\Functional\\Functors\\Monads\\IO;\n\n$readFromFile = function () : string {\n    return file_get_contents('path\/to\/file');\n};\n\n$io = IO::of($readFromFile)\n    ->map('strtoupper')\n    ->bind('var_dump')\n    ->exec();\n\/\/should output the contents of a text file in uppercase\n\nThe Writer Monad\n\nThe Writer monad is designed to make tracking state changes less cumbersome. Unique in its design are a logging mechanism and state transformation helper functions.\n\nuse Chemem\\Bingo\\Functional\\Functors\\Monads\\Writer;\n\nlist($result, $log) = Writer::of(2, 'Initialize')\n    ->bind(\n        function (int $x) : int {\n            return $x + 2;\n        },\n        'Add 2 to x val'\n    )\n    ->run();\n\necho $log;\n\/\/should output messages 'Initialize' and 'Add 2 to x val'\n\nThe Reader Monad\n\nEnvironment variables, like impure operations, break referential transparency. The Reader monad is a solution to the problem of interacting with an external environment. The monad localizes state changes to ensure that functions are kept pure.\n\nuse Chemem\\Bingo\\Functional\\Functors\\Monads\\Reader;\n\nfunction ask(string $content) : Reader\n{\n    return Reader::of(\n        function (string $name) use ($content) {\n            return $content . ($name === 'World' ? '' : ' How are you?');\n        }\n    );\n}\n\nfunction sayHello(string $name) : string\n{\n    return 'Hello ' . $name;\n}\n\n$reader = Reader::of('sayHello')\n    ->withReader('ask')\n    ->run('World');\n\necho $reader; \/\/should output Hello World\n\nThe State Monad\n\nSimilar to the Reader monad is the State monad which works best in situations which require both the transformed and initial states.\n\nuse Chemem\\Bingo\\Functional\\Functors\\Monads\\State;\n\nfunction addThree(int $val) : int\n{\n    return $val + 3;\n}\n\nfunction multiplyByTen(int $val) : int\n{\n    return $val * 10;\n}\n\nlist($original, $finalState) = State::of(2)\n    ->evalState('addThree')\n    ->map('multiplyByTen')\n    ->exec();\n\necho $original; \/\/should output 2\necho $finalState; \/\/should output 50\n\nThe List Monad\n\nThe List Monad is used to generate a set of values for a given collection - something akin to a zip list. The List Monad operates on the principle of [non-determinism](https:\/\/en.wikipedia.org\/wiki\/Nondeterministic_algorithm).\n\nuse Chemem\\Bingo\\Functional\\Functors\\Monads\\ListMonad;\n\nfunction multiplyByTwo(int $val) : int\n{\n    return $val * 2;\n}\n\n$list = ListMonad::of(1, 2, 3)\n    ->bind('multiplyByTwo')\n    ->extract();\n\/\/should evaluate to [2, 4, 6, 1, 2, 3]\n\nMaybe Left\/Nothing types\n\nBorrowed from Haskell is the Maybe type which is composed of two subtypes, Just, and Nothing. The Just type is a functor to which one can bind a value intended for transformation whereas the Nothing type is a null value.\n\nMaybe methods\n\n- fromValue()\n\nThe fromValue() method is one used to bind a value to a Maybe type depending on whether the argument supplied is null or not.\n\n$val = Maybe::fromValue(10); \/\/returns 10 encapsulated in a Right type object\n\n$anotherVal = Maybe::fromValue(null); \/\/returns Nothing - a null value\n\n$yetAnotherVal = Maybe::fromValue(9, 9); \/\/returns Nothing as the Just value and Nothing value cannot be the same\n\n- isJust() and isNothing()\n\nThe isJust() and isNothing() methods simply return boolean values to indicate whether values are either of the Just type or the Nothing type.\n\n$var = Maybe::fromValue(33)\n    ->isJust(); \/\/returns true\n\n$anotherVar = Maybe::fromValue(null)\n    ->isNothing(); \/\/returns true\n\nEither Left\/Right types\n\nAlso borrowed from Haskell is the Either type which, like the Maybe type is comprised of two subtypes which are Left and Right. Naturally, the correct value, the one to be transformed, is an appendage of the Right type class. The error value is the constituent of the Left type class.\n\nuse Chemem\\Bingo\\Functional\\Functors\\Either\\{Either, Left, Right};\n\n$val = Either::right(12); \/\/correct value encapsulated in Right type\n$err = Either::left('Invalid integer'); \/\/error value encapsulated in Left type\n\nEither methods\n\n- partitionEithers()\n\nAs is the case with Haskell, the partitionEithers() method transforms an array of Either type items into a multidimensional array of left and right indexed sub-arrays.\n\n$eithers = [Either::right(12), Either::right(10), Either::left('Invalid Integer')];\n\n$partitionedEithers = Either::partitionEithers($eithers);\n\/\/should return ['left' => ['Invalid Integer'], 'right' => [12, 10]]\n\nCommon methods\n\n- filter()\n\nThe filter() method is one that returns a value which, in this case can be either Right or Just based on a boolean predicate. Usage is similar for both Right and Just types but slightly different for the former functor which requires an error value.\n\n$justVal = Maybe::just(2)\n    ->filter(\n        function (int $a) : bool {\n            return is_int($a);\n        }\n    ); \/\/should return 2 encapsulated in a Just type object\n\n$rightval = Either::right('12')\n    ->filter(\n        function (string $a) : bool {\n            return is_numeric($a);\n        },\n        'Value is not a numeric string'\n    ); \/\/should return '12' encapsulated in a Right type object\n\n- map()\n\nThe map() method makes it possible to mutate functor context by enabling function binding.\n\n$justVal->map(\n    function (int $a) : int {\n        return $a + 10;\n    }\n); \/\/should return 12 encapsulated in a Just type object\n\/\/should work in a similar way for Right type objects\n\n- flatMap()\n\nThe flatMap() method works in a manner similar to the map() method but returns a non-encapsulated value.\n\n$justVal->flatMap(\n    function (int $a) : int {\n        return $a * 10;\n    }\n); \/\/should return 20\n\n- orElse()\n\nThe orElse() method returns a current value if there is one or a given value if there is one.\n\n$user = Either::right(get_current_user())\n    ->orElse(\n        Either::right('foo')\n    ); \/\/returns foo if the current script owner is not defined\n\n- lift()\n\nThe lift() function allows functions expressed in point-free style or otherwise to accept Maybe type values or Either values as arguments.\n\nfunction add(int $a, int $b) : int\n{\n    return $a + $b;\n}\n\n$maybeLifted = Maybe::lift('add');\n$eitherLifted = Either::lift('add', Either::left('Invalid Operation'));\n\n$maybeLifted(\n    Maybe::just(1),\n    Maybe::just(2)\n); \/\/returns 3 encapsulated in a Just type object\n\n$eitherLifted(\n    Either::right(1),\n    Either::right(2)\n);\n\/\/returns 3 encapsulated in a Right type object","description":"Documentation for functors"},{"url":"\/","title":"\/","content":"[bingo-functional logo]\n[Chat on Gitter] [Build Status] [Codacy Badge] [Codecov] [Latest Stable Version] [License] [Total Downloads] [Twitter]\n\nThe bingo-functional library is a functional programming library built in PHP for PHP users. Available in this library are monads, Just\/Nothing types, Left\/Right types, applicative functors, and function algorithms meant to ease the cognitive burden for those who intend to use them. The subsequent text is documentation of the library which should help you, the reader, understand how to go about using it.\n\nInstallation\n\nBefore you can use the bingo-functional library, you should have either Git or Composer installed on your system of preference. To install the package via Composer, type the following in your preferred command line interface:\n\ncomposer require chemem\/bingo-functional\n\nTo install via Git - without Composer, type:\n\ngit clone https:\/\/github.com\/ace411\/bingo-functional.git\n\nUpon successful installation, add the following statement to the summit of all the scripts in which you intend to use the library's functions and functors.\n\nrequire_once __DIR__ . '\/autoload.php';\n\nUsage\n\nThe bingo-functional library's utilities are namespaced. Below is a listing of all the package's offerings and their respective namespaces:\n\nUtility\tNamespace\nHelper Functions\tChemem\\Bingo\\Functional\\Algorithms\\\nMonads\tChemem\\Bingo\\Functional\\Functors\\Monads\\\nApplicatives\tChemem\\Bingo\\Functional\\Functors\\Applicatives\\\nUnion Types\tChemem\\Bingo\\Functional\\Functors\\{Either or Maybe}\nPattern Matching Functions\tChemem\\Bingo\\Functional\\PatternMatching\\","description":"Installation of library"},{"url":"\/pattern-matching.html","title":"\/pattern-matching.html","content":"The goal of pattern matching is to bind values to successful matches. Pattern matching is similar to the switch statement. The patterns used in the pattern-matching function are a near facsimile of the [Haskell pattern-matching patterns](https:\/\/en.wikibooks.org\/wiki\/Haskell\/Pattern_matching). Because pattern matching is a core feature of a language like Haskell, implementing it in PHP is quite the uphill task. The bingo-functional library has two pattern matching functions that conform to the patterns shown in the table below: match and patternMatch.\n\nPattern name\tFormat\tExamples\nconstant\tA scalar value\t12, 12.02, \"foo\"\nvariable\tAny value identifier\tfoo, bar, baz\narray\t[constant, ..., variable]\t'[\"foo\", \"bar\", baz]'\ncons\t(identifier:identifier)\t(foo:bar:_)\nwildcard\t_\t'_'\n\nThe pattern matching subset of the bingo-functional library is quite similar to the [pattern-matching library](https:\/\/packagist.org\/packages\/functional-php\/pattern-matching) created by [Gilles Crettenand](https:\/\/github.com\/krtek4). It is, in fact, inspired by the works of the said individual.\n\nmatch function\n\nmatch(array $patterns)(array $values)\n\nSince: v1.8.0\n\nArguments:\n\n- patterns (array) - The patterns to evaluate\n- values (array) - The values for comparison\n\nThe match function deals primarily with cons, values separated by a colon. The cons serve as arguments for the accompanying lambdas: each cons pattern has a wildcard before its closing brace.\n\nuse Chemem\\Bingo\\Functional\\PatternMatching as PM;\n\n$match = PM\\match(\n    [\n        '(x:xs:_)' => function (int $x, int $xs) {\n            return $x \/ $xs;\n        },\n        '(x:_)' => function (int $x) {\n            return $x * 2;\n        },\n        '_' => function () {\n            return 1;\n        }\n    ]\n);\n\n$result = $match([10, 5]);\n\npatternMatch function\n\npatternMatch(array $patterns, mixed $values)\n\nSince: v1.8.1\n\nArguments:\n\n- patterns (array) - The patterns to evaluate\n- values (mixed) - The values for comparison\n\nThe pattern match function is useful for array content comparisons like URL and switch statement-driven matches. The patternMatch function combines arrays, constants, and variables and assesses the specificity of each pattern provided.\n\nThe patternMatch function can detect string matches for single scalar values and evaluate the right function bindings based on value specifics.\n\nuse Chemem\\Bingo\\Functional\\PatternMatching as PM;\n\n$scalarMatch = PM\\patternMatch(\n    [\n        '\"foo\"' => function () {\n            $val = strtoupper('foo');\n\n            return $val;\n        },\n        '\"bar\"' => function () {\n            return 'bar';\n        },\n        '_' => function () {\n            return 'undefined';\n        }\n    ],\n    'foo'\n); \/\/outputs FOO\n\nThe patternMatch function's primary feature, the array match is possible for multiple values parsed into an array.\n\n$arrayMatch = PM\\patternMatch(\n    [\n        '[\"foo\", \"bar\", baz]' => function (string $baz) {\n            $val = lcfirst(strtoupper($baz));\n\n            return $val;\n        },\n        '[\"foo\", \"bar\"]' => function () {\n            $val = strtoupper('foo-bar');\n\n            return $val;\n        },\n        '_' => function () {\n            return 'undefined';\n        }\n    ],\n    ['foo', 'bar', 'functional']\n); \/\/outputs fUNCTIONAL","description":"Pattern Matching docs"},{"url":"\/repl.html","title":"\/repl.html","content":"The [bingo-functional console](https:\/\/github.com\/ace411\/bingo-functional-repl) is an appendage of the bingo-functional set of utilities. Capable of parsing idiomatic PHP input, the bingo-functional REPL is one predicated on providing a playground for interaction with the bingo-functional range of functions and functors.\n\nInstallation\n\nTo install the bingo-functional REPL, type the following text in a command line of your choosing:\n\ncomposer require chemem\/bingo-functional-repl\n\nSupported Expressions\n\nThe bingo-functional console uses the [PHP parser](https:\/\/github.com\/nikic\/PHP-Parser) written by [Nikita Popov](https:\/\/github.com\/nikic). The premise of the console is extending script-executable bingo-functional functions to the command-line. The console, therefore, supports a limited range of actions listed below:\n\n- the echo statement followed by either a string or number or float\n\nbingo-functional> echo \"foo\"\nResult: \"foo\"\nbingo-functional> echo 12\nResult: 12\nbingo-functional> echo 2.552\nResult: 2.552\n\n- bingo-functional library-specific calls which can take on single or multiple inline function calls\n\nbingo-functional> curry(function ($a, $b) {return $a \/ $b;})(12)(6)\nResult: 2\nbingo-functional> map(function ($val) {return $val * 2;}, [1, 2, 3])\nResult: [2,4,6]\n\n- bingo-functional library monad-specific static expressions which output serialized objects or scalar values upon parsing\n\nbingo-functional> State::of(1)->map(function ($a) {return $a + 3;})\nResult: <State> [1,4]\nbingo-functional> Either::pure(12)->flatMap(function ($a) {return $a * 2;})\nResult: 24\n\n- constants limited to the help and version directives\n\nbingo-functional> version\nResult: 1.0.0\n\nImportant\n\n-\n\nSemi-colons are not required\n\n-\n\nTo make the most of the console experience, read the rest of the bingo-functional documentation.","description":"bingo-functional REPL docs"}]