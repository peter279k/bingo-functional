<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">

        <title>docs</title>

        <link rel="stylesheet" href="https://ace411.github.io/bingo-functional/css/bootstrap.min.css">
        <link rel="stylesheet" href="https://ace411.github.io/bingo-functional/css/font-awesome.min.css">
        <link rel="stylesheet" href="https://ace411.github.io/bingo-functional/css/highlight.dark.css">
        <link rel="stylesheet" href="https://ace411.github.io/bingo-functional/css/main.css">
    </head>
    <body>

        <header class="navbar navbar-default navbar-fixed-top">

            <a class="navbar-brand" href="https://ace411.github.io/bingo-functional/">
                docs
                <small class="hidden-xs hidden-sm">
                    Documentation for library
                </small>
            </a>

                            <a href="https://github.com/ace411/bingo-functional">
                    <img style="position: absolute; top: 0; right: 0; border: 0;" src="https://camo.githubusercontent.com/38ef81f8aca64bb9a64448d0d70f1308ef5341ab/68747470733a2f2f73332e616d617a6f6e6177732e636f6d2f6769746875622f726962626f6e732f666f726b6d655f72696768745f6461726b626c75655f3132313632312e706e67" alt="Fork me on GitHub" data-canonical-src="https://s3.amazonaws.com/github/ribbons/forkme_right_darkblue_121621.png">
                </a>
            
        </header>

        <main class="container-fluid">
            <div class="row">

                
                    <nav id="sidebar" class="col-sm-3 col-lg-2" role="navigation">

                        <ul class="nav nav-pills nav-stacked">
                                                            <li class="">
                                    <a href="https://ace411.github.io/bingo-functional/">
                                        Introduction
                                    </a>
                                </li>
                                                            <li class="">
                                    <a href="https://ace411.github.io/bingo-functional/main.html">
                                        Docs
                                    </a>
                                </li>
                                                            <li class="">
                                    <a href="https://ace411.github.io/bingo-functional/changes.html">
                                        Changes
                                    </a>
                                </li>
                                                    </ul>

                    </nav>

                
                <section id="content" class="col-sm-offset-3 col-lg-offset-2 col-sm-9 col-lg-10">
                    <h1 id="bingo-functional-documentation">bingo-functional documentation</h1>
<p>The bingo-functional library is a functional programming library built in PHP for PHP users. Available in this library are monads, Just/Nothing types, Left/Right types, applicative functors, and function algorithms meant to ease the cognitive burden for those who intend to use them. The subsequent text is documentation of the library which should help you, the reader, understand how to go about using it.</p>
<h2 id="installation">Installation</h2>
<p>Before you can use the bingo-functional library, you should have either Git or Composer installed on your system of preference. To install the package via Composer, type the following in your preferred command line interface:</p>
<pre><code>composer require chemem/bingo-functional</code></pre>
<p>To install via Git, type:</p>
<pre><code>git clone https://github.com/ace411/bingo-functional.git</code></pre>
<h2 id="algorithms">Algorithms</h2>
<h3 id="composing-functions">Composing functions</h3>
<p>The ability to combine functions is a concept borrowed from mathematics. Simply put, composition is applying a function to the output of another function thereby transforming it. A function f and another function g can be 'composed' to create a function f o g.</p>
<pre><code class="language-php">use Chemem\Bingo\Functional\Algorithms as A;

$composed = A\compose(
    function (int $a) : int {
        return $a + 10;
    },
    function (int $a) : int {
        return $a * 10;
    }
); //could be any callable value(s)

$output = array_map($composed, [1, 2, 3]);
//should return [110, 120, 130]</code></pre>
<h3 id="partial-application">Partial application</h3>
<p>If the intention is to supply parameters to a function incrementally, partial application is a possible solution. At the core of partial application is binding arguments to a function.</p>
<pre><code class="language-php">
$partial = A\partial(
    function (int $a, int $b) : int {
        return $a + $b;
    },
    1
); //bind the argument 1 to the function

$partial(2); //bind 2 to the function; should return 3</code></pre>
<h4 id="partial-left">Partial-Left</h4>
<p>Works just like the partial function. Arguments are, with the partialLeft function, incrementally supplied from left to right.</p>
<pre><code class="language-php">$partialLeft = A\partialLeft(
    function (int $a, int $b) : int {
        return $a - $b;
    },
    12
);

$partialLeft(9); //should output 3</code></pre>
<h4 id="partial-right">Partial-Right</h4>
<p>This is the antipode of the partialLeft function. The argument order is right to left.</p>
<pre><code class="language-php">$partialRight = A\partialRight(
    function (int $a, int $b) : int {
        return $a - $b;
    },
    9
);

$partialRight(12); //outputs 3</code></pre>
<h3 id="currying">Currying</h3>
<p>Related to partial application is currying which is premised on splitting a higher-order function into smaller functions each taking a single argument. The idea of binding arguments to a function incrementally features strongly here as well.</p>
<pre><code class="language-php">
$curryied = A\curry(
    function (int $a, int $b) : int {
        return $a * $b;
    }
);

$curryied(4)(5); //should return 20</code></pre>
<h4 id="curryn">CurryN</h4>
<p>The curryN function allows for specifying the number of parameters to curry. This can be used for functions with default/optional parameters.</p>
<pre><code class="language-php">
$curryied = A\curryN(
    2,
    function (int $a, int $b, int $c = null) : int {
        return $a + $b + $c;
    }
);

$curryied(2)(3); //should return 5</code></pre>
<h3 id="picking">Picking</h3>
<p>Picking is a means of selecting an item from a list. This list, is, usually an array.</p>
<pre><code class="language-php">use Chemem\Bingo\Functional\Common\Callbacks as CB;

$list = ['Spurs', 'Rockets', 'Heat', 'Pelicans'];

$picked = A\pick($list, 'Heat', CB\invalidArrayValue); //modified to accept a callback parameter
//returns 'Heat'</code></pre>
<h3 id="plucking">Plucking</h3>
<p>Like picking, plucking is a means of selecting an item from a list. The difference is in the means of selection. Plucking selects an item by index.</p>
<pre><code class="language-php">use Chemem\Bingo\Functional\Common\Callbacks as CB;

$list = ['PG' =&gt; 'Dragic', 'SG' =&gt; 'Reddick', 'SF' =&gt; 'Durant'];

$plucked = A\pluck($list, 'SF', CB\invalidArrayKey); //also modified to accept a callback parameter
//returns 'Durant'</code></pre>
<h3 id="zipping">Zipping</h3>
<p>Also used to manipulate lists is zipping. A zipped array is a multidimensional array of grouped arrays. It can be created either via function binding or array key combination.</p>
<pre><code class="language-php">
$pos = ['PG', 'SG', 'SF'];
$players = ['Dragic', 'Reddick', 'Durant'];

$zippedKeys = A\zip(null, $pos, $players); //key combination
//should return [['PG', 'Dragic'], ['SG', 'Reddick'], ['SF', 'Durant']]

$zippedFn = A\zip(
    function (string $player, string $pos) : string {
        return $player . ' is a ' . $pos;
    },
    $players,
    $pos
);
//should return ['Dragic is a PG', 'Reddick is a SG', 'Durant is a SF']</code></pre>
<h3 id="unzipping">Unzipping</h3>
<p>The antithesis of zipping, unzipping involves transforming a zipped array into a multidimensional array of non-grouped arrays.</p>
<pre><code class="language-php">//borrowing from the previous snippet

$unzipped = A\unzip($zippedKeys);
//should return [['PG', 'SG', 'SF'], ['Dragic', 'Reddick', 'Durant']]</code></pre>
<h3 id="identity">Identity</h3>
<p>Central to the identity law of functors is the identity function. This function is pretty straightforward; it returns the value it receives with no transformations whatsoever.</p>
<pre><code class="language-php">
$id = A\identity('foo');
//should return foo</code></pre>
<h3 id="constant-function">Constant function</h3>
<p>The constant function is one that always returns the first argument it receives.</p>
<pre><code class="language-php">
$const = A\constantFunction(1);
$const(); //should return 1</code></pre>
<h3 id="extend">Extend</h3>
<p>The extend function is inspired by a similar bilby.js functional library. This helper is, in essence, used on arrays and allows one to append elements to them.</p>
<pre><code class="language-php">$players = ['PG' =&gt; 'Dragic', 'SG' =&gt; 'Winslow'];

$extended = A\extend($players, ['SF' =&gt; 'Durant', 'PG' =&gt; 'Curry']);
//should return ['PG' =&gt; 'Curry', 'SG' =&gt; 'Winslow', 'SF' =&gt; 'Durant']</code></pre>
<h3 id="memoize-function">Memoize function</h3>
<p>Sometimes, a computation might be expensive. Memoization ensures that the output of a computed result is cached and conveyed.</p>
<pre><code class="language-php">$factorial = A\memoize(
    function (int $num) use (&amp;$factorial) {
        return $num &lt; 2 ? 1 : $factorial($num - 1) * $num;
    }
);

$factorial(130); //outputs float(6.4668554892205E+219)</code></pre>
<h3 id="head-function">Head function</h3>
<p>The output of the head function is the first value of an array.</p>
<pre><code class="language-php">
$head = A\head([1, 2, 3, 4]);
//returns 1</code></pre>
<h3 id="tail-function">Tail function</h3>
<p>Contrary to the head function, the tail function returns the second to last values in an array.</p>
<pre><code class="language-php">
$tail = A\tail([1, 2, 3, 4]);
//returns [2, 3, 4]</code></pre>
<h3 id="indexof-function">indexOf function</h3>
<p>The indexOf function computes the list index of a given list item.</p>
<pre><code class="language-php">$index = A\indexOf([1, 2, 3, 4], 2);

echo $index; //outputs 1</code></pre>
<h3 id="fill-function">Fill function</h3>
<p>The fill function replaces the values of specified list indexes with an arbitrary value.</p>
<pre><code class="language-php">$filled = A\fill([2, 4, 6, 7], 3, 1, 2);

var_dump($filled); //outputs [2, 3, 3, 7]</code></pre>
<h3 id="partitioning">Partitioning</h3>
<p>The partition function one which can be used to create a multidimensional array expressed as a collection of smaller arrays of a defined size.</p>
<pre><code class="language-php">$partitioned = A\partition(2, [1, 2, 3, 4]);
//returns [[1, 2], [3, 4]]</code></pre>
<h3 id="throttle-function">Throttle function</h3>
<p>The throttle function is used to defer function processing.</p>
<pre><code class="language-php">$addTwelve = function (int $val) : int {
    return $val + 12;
};

$throttle = A\throttle($addTwelve, 10);

echo $throttle(0);
//prints the digit 12 after 10 seconds</code></pre>
<p><strong>Note:</strong> The throttle function as of v1.7.1 supports functions with multiple arguments.</p>
<h3 id="isarrayof-function">isArrayOf function</h3>
<p>Returns a string identifying the predominant type of the array. Arrays with more than one type are considered mixed.</p>
<pre><code class="language-php">use Chemem\Bingo\Functional\Common\Callbacks as CB;

$integers = [1, 2, 3, 4];

echo A\isArrayOf($integers, CB\emptyArray);
//prints 'integer'</code></pre>
<h3 id="concat-function">concat function</h3>
<p>The concat() function concatenates strings. It appends strings onto each other sequentially. It requires a wildcard separator though.</p>
<pre><code class="language-php ">$wildcard = ' ';

echo A\concat($wildcard, 'Kampala', 'is', 'hot');
//should print 'Kampala is hot'</code></pre>
<h3 id="map-function">Map function</h3>
<p>The map function transforms each entry in a collection. The requirements for this are a function whose return value dictates the transformation and an array of values.</p>
<pre><code class="language-php">$collection = [2, 4, 6, 8];

$squareOf = A\map(
    function (int $val) : int {
        return pow($val, 2);
    }, 
    $collection
); //should evaluate to [4, 16, 36, 64]</code></pre>
<h3 id="filter-function">Filter function</h3>
<p>To filter is to make a selection based on a boolean predicate - the filter function, therefore, makes it possible to select array values based on a filter function's boolean return value.</p>
<pre><code class="language-php">$collection = [1, 2, 3, 4, 5, 6];

$even = A\filter(
    function (int $val) : bool {
        return $val % 2 === 0;
    },
    $collection
);
//should return [2, 4, 6]</code></pre>
<h3 id="foldreduce-function">Fold/Reduce function</h3>
<p>The reduce function otherwise known as the fold function is one used purposely to transform a collection into a single value.</p>
<pre><code class="language-php ">$collection = [1, 2, 3, 4, 5, 6];

$sumOfEven = A\fold(
    function (int $acc, int $val) : int {
        return $val % 2 === 0 ? $acc + $val : $acc;
    },
    $collection,
    0
); 
//should evaluate to 12</code></pre>
<h3 id="unique-function">Unique function</h3>
<p>The unique function removes duplicates from an array.</p>
<pre><code class="language-php">$numbers = [1, 2, 3, 4, 1];

$unique = A\unique($numbers); //should return [1, 2, 3, 4]</code></pre>
<h3 id="compact-function">Compact function</h3>
<p>The compact function purges an array of falsey values (null, false).</p>
<pre><code class="language-php">$collection = [1, 2, 3, false, null];

$numbers = A\compact($collection); //evaluates to [1, 2, 3]</code></pre>
<h3 id="drop-function">Drop function</h3>
<p>The drop functions remove items from a list. The <code>dropLeft()</code> function removes elements from the front of a collection. The <code>dropRight()</code> function, on the other hand, removes elements from the back of a list.</p>
<pre><code class="language-php">$even = [2, 4, 6, 8, 10, 12];

//dropLeft
$leftDrop = A\dropLeft($even, 3); //evaluates to [8, 10, 12]

//dropRight
$rightDrop = A\dropRight($even, 3); //evaluates to [2, 4, 6]</code></pre>
<h3 id="flatten-function">Flatten function</h3>
<p>The flatten function reduces an array level count by one.</p>
<pre><code class="language-php">$collection = [[1, 2], 'foo', 'bar'];

$flattened = A\flatten($collection); //evaluates to [1, 2, 'foo', 'bar']</code></pre>
<h3 id="arraykeysexist-function">ArrayKeysExist function</h3>
<p>The arrayKeysExist function determines whether specified keys match the indexes of the values in an array and therefore exist in a collection.</p>
<pre><code class="language-php">$attributes = ['username' =&gt; 'foo', 'password' =&gt; 'bar'];

$keysExist = A\arrayKeysExist($attributes, 'username', 'password'); //should evaluate to true</code></pre>
<h3 id="reverse-function">Reverse function</h3>
<p>The reverse function computes the reverse of an array.</p>
<pre><code class="language-php">$reverse = A\reverse(['foo', 'bar', 'baz']);

var_dump($reverse); //outputs ['baz', 'bar', 'foo']</code></pre>
<h3 id="topairs-function">ToPairs function</h3>
<p>The toPairs function combines key-value pairs into discrete array pairs.</p>
<pre><code class="language-php">$toPairs = A\toPairs(['foo' =&gt; 'baz', 'bar' =&gt; 'baz', 'boo' =&gt; 1]);

var_dump($toPairs); //prints [['foo', 'baz'], ['bar', 'baz'], ['boo', 1]]</code></pre>
<h3 id="frompairs-function">FromPairs function</h3>
<p>The fromPairs function forms key-value pairs from discrete array pairs - it is the opposite of the toPairs function.</p>
<pre><code class="language-php">$fromPairs = A\fromPairs([['foo', 'baz'], ['bar', 'baz'], ['boo', 1]]);

var_dump($fromPairs); //outputs ['foo' =&gt; 'baz', 'bar' =&gt; 'baz', 'boo' =&gt; 1]</code></pre>
<h2 id="pattern-matching">Pattern Matching</h2>
<p>The goal of pattern matching is to bind values to successful matches. Pattern matching is similar to the switch statement.The patterns used in the pattern-matching function are a near facsimile of the <a href="https://en.wikibooks.org/wiki/Haskell/Pattern_matching">Haskell pattern-matching patterns</a>. </p>
<pre><code class="language-php">$match = Chemem\Bingo\Functional\PatternMatching\match([
    '(a:b:_)' =&gt; function (int $a, int $b) {
        return $a / $b;
    },
    '(a:_)' =&gt; function (int $a) {
        return $a * 2;
    },
    '_' =&gt; function () {
        return 1;
    }
]);

$result = $match([10, 5]); //computes 10/5 and outputs 2</code></pre>
<p><strong>Note:</strong> The match function is curryied. The first argument is a pattern-function key-value list and the second, an array of values.</p>
<h3 id="callback-signatures">Callback signatures</h3>
<p><strong>Note:</strong> Callbacks will not be usable beyond bingo-functional v1.7.2. Check out the <a href="https://ace411.github.io/bingo-functional/changes">changelog</a>.</p>
<p>These are essential for proper functioning of the the following helper functions: <code>pluck()</code>, <code>pick()</code>, <code>memoize()</code>, as well as <code>isArrayOf()</code>. The following callback signatures correspond to the functions listed:</p>
<ul>
<li>
<p><code>invalidArrayKey :: key -&gt; errMsg</code></p>
</li>
<li>
<p><code>invalidArrayValue :: key -&gt; errMsg</code></p>
</li>
<li>
<p><code>memoizationError :: Callable fn -&gt; errMsg</code></p>
</li>
<li>
<p><code>emptyArray :: Nothing -&gt; errMsg</code> </p>
</li>
</ul>
<p><strong>Note:</strong> You can write your own callbacks provided they adhere to the signatures listed above.</p>
<h2 id="functors">Functors</h2>
<p>A functor is an entity derived from Category Mathematics. Functors allow one to map functions to one or more values defined in their context. Functors are, therefore, the data structures that form the basis for Monads, Applicatives, Just/Nothing types, and Left/Right types.</p>
<h3 id="applicatives">Applicatives</h3>
<p>An applicative is a functor which conforms to certain laws - interchange, map, identity, and homomorphism. The most pervasive element of applicatives is the ability to apply a function to the values in their context.</p>
<p>Functions, arrays, objects, and primitives can be encapsulated in Applicatives.</p>
<pre><code class="language-php">use Chemem\Bingo\Functional\Functors\{CollectionApplicative, Applicative};

$num = Applicative::pure(10); //should return an integer, 10 encapsulated in an Applicative object

$addTen = Applicative::pure(
    function (int $a) : int {
        return $a + 10;
    }
); //should return a Closure object encapsulated in an Applicative object</code></pre>
<h4 id="collectionapplicatives">CollectionApplicatives</h4>
<p>Applicatives and CollectionApplicatives are not entirely dissimilar. The latter functors are indeed applicatives but more amenable to the creation of <a href="http://hackage.haskell.org/package/base-4.10.0.0/docs/Control-Applicative.html#v:ZipList">ziplists</a>, which are, fundamentally, traversable data structures.</p>
<pre><code class="language-php">$zipList = CollectionApplicative::pure([
    $addTen,
    function (int $a) : int {
        return $a * 10;
    }
])
-&gt;apply(
    CollectionApplicative::pure([1, 2, 3])
)
-&gt;getValues();
//should return [11, 12, 13, 10, 20, 30]</code></pre>
<p><strong>Using the apply method</strong></p>
<p>The apply method is simply a means of binding an argument to a function defined in the context of an Applicative. It is especially convenient for state transformations within a functor environment.</p>
<pre><code class="language-php">
$addTen-&gt;apply($num)
    -&gt;getValue(); //should return 20</code></pre>
<h3 id="monad">Monad</h3>
<p>The monad implementation in this library is a simple one. Considering the existence of a complete genealogy of monads, the monad class in this library is a microcosm of the feature. Monads allow us to manipulate values within their context like Applicatives but return monads of the same type when functions are bound to them.</p>
<pre><code class="language-php">use Chemem\Bingo\Functional\Functors\Monad;

$val = Monad::return(10)
    -&gt;bind(
        function (int $val) : int {
            return $val + 10;
        }
    ); //returns the value 10 encapsulated in a Monad object</code></pre>
<p><strong><em>Monads</em></strong> map functions onto values stored inside their contexts whereas <strong><em>Applicatives</em></strong> bind values to the functions stored inside theirs.</p>
<p><strong>Note:</strong> As of version 1.4.0, the Monad class will not be available. Refer to the <a href="https://github.com/ace411/bingo-functional/blob/master/docs/changes.html">change log</a> for more details.</p>
<h4 id="the-io-monad">The IO Monad</h4>
<p>The IO monad is one built purposely for handling impure operations. Impure operations are those that break referential transparency and immutability. Database interactions, Web service interaction, as well as external file reads are impediments to referential transparency.</p>
<pre><code class="language-php">use Chemem\Bingo\Functional\Functors\Monads\IO;

$readFromFile = function () : string {
    return file_get_contents('path/to/file');
};

$io = IO::of($readFromFile)
    -&gt;map('strtoupper')
    -&gt;bind('var_dump')
    -&gt;exec();
//should output the contents of a text file in uppercase</code></pre>
<h4 id="the-writer-monad">The Writer Monad</h4>
<p>The Writer monad is designed to make tracking state changes less cumbersome. Unique in its design are a logging mechanism and state transformation helper functions.</p>
<pre><code class="language-php">use Chemem\Bingo\Functional\Functors\Monads\Writer;

list($result, $log) = Writer::of(2, 'Initialize')
    -&gt;bind(
        function (int $x) : int {
            return $x + 2;
        },
        'Add 2 to x val'
    )
    -&gt;run();

echo $log;
//should output messages 'Initialize' and 'Add 2 to x val'</code></pre>
<h4 id="the-reader-monad">The Reader Monad</h4>
<p>Environment variables, like impure operations, break referential transparency. The Reader monad is a solution to the problem of interacting with an external environment. The monad localizes state changes to ensure that functions are kept pure.</p>
<pre><code class="language-php">use Chemem\Bingo\Functional\Functors\Monads\Reader;

function ask(string $content) : Reader
{
    return Reader::of(
        function (string $name) use ($content) {
            return $content . ($name === 'World' ? '' : ' How are you?'); 
        }
    );
}

function sayHello(string $name) : string
{
    return 'Hello ' . $name;
}

$reader = Reader::of('sayHello')
    -&gt;withReader('ask')
    -&gt;run('World');

echo $reader; //should output Hello World</code></pre>
<h4 id="the-state-monad">The State Monad</h4>
<p>Similar to the Reader monad is the State monad which works best in situations which require both the transformed and initial states.</p>
<pre><code class="language-php">use Chemem\Bingo\Functional\Functors\Monads\State;

function addThree(int $val) : int
{
    return $val + 3;
}

function multiplyByTen(int $val) : int
{
    return $val * 10;
}

list($original, $finalState) = State::of(2)
    -&gt;evalState('addThree')
    -&gt;map('multiplyByTen')
    -&gt;exec();

echo $original; //should output 2
echo $finalState; //should output 50</code></pre>
<h4 id="the-list-monad">The List Monad</h4>
<p>The List Monad is used to generate a set of values for a given collection - something akin to a zip list. The List Monad operates on the principle of <a href="https://en.wikipedia.org/wiki/Nondeterministic_algorithm">non-determinism</a>.</p>
<pre><code class="language-php">use Chemem\Bingo\Functional\Functors\Monads\ListMonad;

function multiplyByTwo(int $val) : int
{
    return $val * 2;
}

$list = ListMonad::of(1, 2, 3)
    -&gt;bind('multiplyByTwo')
    -&gt;extract();
//should evaluate to [2, 4, 6, 1, 2, 3]</code></pre>
<h3 id="maybe-leftnothing-types">Maybe Left/Nothing types</h3>
<p>Borrowed from Haskell is the Maybe type which is composed of two subtypes, Just, and Nothing. The Just type is a functor to which one can bind a value intended for transformation whereas the Nothing type is a null value.</p>
<h4 id="maybe-methods">Maybe methods</h4>
<ul>
<li><strong>fromValue()</strong></li>
</ul>
<p>The <code>fromValue()</code> method is one used to bind a value to a Maybe type depending on whether the argument supplied is null or not.</p>
<pre><code class="language-php">$val = Maybe::fromValue(10); //returns 10 encapsulated in a Right type object

$anotherVal = Maybe::fromValue(null); //returns Nothing - a null value

$yetAnotherVal = Maybe::fromValue(9, 9); //returns Nothing as the Just value and Nothing value cannot be the same</code></pre>
<ul>
<li><strong>isJust() and isNothing()</strong></li>
</ul>
<p>The <code>isJust()</code> and <code>isNothing()</code> methods simply return boolean values to indicate whether values are either of the Just type or the Nothing type.</p>
<pre><code class="language-php">
$var = Maybe::fromValue(33)
    -&gt;isJust(); //returns true

$anotherVar = Maybe::fromValue(null)
    -&gt;isNothing(); //returns true</code></pre>
<h3 id="either-leftright-types">Either Left/Right types</h3>
<p>Also borrowed from Haskell is the Either type which, like the Maybe type is comprised of two subtypes which are Left and Right. Naturally, the correct value, the one to be transformed, is an appendage of the Right type class. The error value is the constituent of the Left type class.</p>
<pre><code class="language-php">use Chemem\Bingo\Functional\Functors\Either\{Either, Left, Right};

$val = Either::right(12); //correct value encapsulated in Right type
$err = Either::left('Invalid integer'); //error value encapsulated in Left type</code></pre>
<h4 id="either-methods">Either methods</h4>
<ul>
<li><strong>partitionEithers()</strong></li>
</ul>
<p>As is the case with Haskell, the <code>partitionEithers()</code> method transforms an array of Either type items into a multidimensional array of left and right indexed sub-arrays.</p>
<pre><code class="language-php">
$eithers = [Either::right(12), Either::right(10), Either::left('Invalid Integer')];

$partitionedEithers = Either::partitionEithers($eithers);
//should return ['left' =&gt; ['Invalid Integer'], 'right' =&gt; [12, 10]]</code></pre>
<h4 id="common-methods">Common methods</h4>
<ul>
<li><strong>filter()</strong></li>
</ul>
<p>The <code>filter()</code> method is one that returns a value which, in this case can be either Right or Just based on a boolean predicate. Usage is similar for both Right and Just types but slightly different for the former functor which requires an error value.</p>
<pre><code class="language-php">$justVal = Maybe::just(2)
    -&gt;filter(
        function (int $a) : bool {
            return is_int($a);
        }
    ); //should return 2 encapsulated in a Just type object

$rightval = Either::right('12')
    -&gt;filter(
        function (string $a) : bool {
            return is_numeric($a);
        },
        'Value is not a numeric string'
    ); //should return '12' encapsulated in a Right type object</code></pre>
<ul>
<li><strong>map()</strong></li>
</ul>
<p>The <code>map()</code> method makes it possible to mutate functor context by enabling function binding.</p>
<pre><code class="language-php">
$justVal-&gt;map(
    function (int $a) : int {
        return $a + 10;
    }
); //should return 12 encapsulated in a Just type object
//should work in a similar way for Right type objects</code></pre>
<ul>
<li><strong>flatMap()</strong></li>
</ul>
<p>The <code>flatMap()</code> method works in a manner similar to the <code>map()</code> method but returns a non-encapsulated value.</p>
<pre><code class="language-php">
$justVal-&gt;flatMap(
    function (int $a) : int {
        return $a * 10;
    }
); //should return 20</code></pre>
<ul>
<li><strong>orElse()</strong></li>
</ul>
<p>The <code>orElse()</code> method returns a current value if there is one or a given value if there is one.</p>
<pre><code class="language-php">$user = Either::right(get_current_user())
    -&gt;orElse(
        Either::right('foo')
    ); //returns foo if the current script owner is not defined</code></pre>
<ul>
<li><strong>lift()</strong></li>
</ul>
<p>The <code>lift()</code> function allows functions expressed in point-free style or otherwise to accept Maybe type values or Either values as arguments.</p>
<pre><code class="language-php">function add(int $a, int $b) : int
{
    return $a + $b;
}

$maybeLifted = Maybe::lift('add');
$eitherLifted = Either::lift('add', Either::left('Invalid Operation'));

$maybeLifted(
    Maybe::just(1),
    Maybe::just(2)
); //returns 3 encapsulated in a Just type object

$eitherLifted(
    Either::right(1),
    Either::right(2)
);
//returns 3 encapsulated in a Right type object</code></pre>
                </section>

            </div>
        </main>

        <footer>
            <div class="container-fluid">
                <p class="text-muted">
                    website generated with <a href="http://couscous.io" title="Markdown website generator">Couscous</a>
                </p>
            </div>
        </footer>

        <script src="//code.jquery.com/jquery-1.11.0.min.js"></script>
        <script src="//netdna.bootstrapcdn.com/bootstrap/3.1.1/js/bootstrap.min.js"></script>
        <script src="//yastatic.net/highlightjs/8.2/highlight.min.js"></script>

        <script>
            $(function() {
                $("section>h1").wrap('<div class="page-header" />');
                // Syntax highlighting
                hljs.initHighlightingOnLoad();
            });
        </script>

    </body>
</html>
